---
title: Como criar um blog usando Next + MDX
description: O jeito mais simples para hospedar suas postagens!
language: üáßüá∑
date: "2021-10-14"
bannerUrl: https://res.cloudinary.com/ilher-dev/image/upload/c_fit,h_600,o_100/v1634158318/johannes-plenio-qkfxBc2NQ18-unsplash_qi0bui.webp
bannerAlt: Sunset
bannerCredit: Photo by [Johannes Plenio](https://unsplash.com/photos/qkfxBc2NQ18)
---
Primeiramente sejam todos muito bem vindos! Esse ser√° o primeiro post desse meu blog, em portugu√™s, completamente servido pela [Vercel](https://vercel.com/)! Nunca tive essa experi√™ncia de escrever, mas quero ter essa oportunidade de repassar meu conhecimento dentro desse mundo da tecnologia.

Vamos colocar a m√£o na massa e construir um blog super simples, mas com funcionalidades super ut√©is para te integrar ainda mais no universo do Next.js. Al√©m disso utilizaremos o [TailwindCSS](https://tailwindcss.com/) para dar uma *tunada* em nossa aplica√ß√£o.

Para come√ßar, iremos iniciar um projeto `Next` via cli. Neste exemplo utilizarei o `yarn`:

```sh
yarn create next-app my-blog
```

Ap√≥s o projeto ser iniciado, iremos adicionar as depend√™ncias necess√°rias para nosso projeto:

```sh
yarn add next-mdx-remote gray-matter tailwindcss@latest postcss@latest autoprefixer@latest -D
```

## O que √© MDX?
MDX √© um formato que nos deixa importar c√≥digos JSX dentro de nosso arquivo *Markdown*. Com isso, escrever cont√©udos fica mais f√°cil, al√©m de ser poss√≠vel utilizar componentes espec√≠ficos do React para melhorar ainda mais a visualiza√ß√£o. Al√©m disso, n√£o precisaremos de nenhum tipo de gerenciador de cont√©udo, apenas um lugar para servir nossa aplica√ß√£o. **Todo** conte√∫do ficara junto do nosso c√≥digo fonte.

Para lidarmos com MDX estaremos utilizando o pacote [next-mdx-remote](https://github.com/hashicorp/next-mdx-remote).

## E o TailwindCSS?
TailwindCSS √© um framework CSS mega completo para gerenciarmos a estiliza√ß√£o da nossa p√°gina. Para continuarmos com nossa aplica√ß√£o, √© necess√°rio iniciar o Tailwind na raiz do nosso projeto:

```sh
npx tailwindcss init -p
```

Ap√≥s isso, os arquivos `tailwind.config.js` e `postcss.config.js` ser√£o criados na ra√≠z do nosso projeto. Agora, iremos instalar o plugin do Tailwind que ir√° prover estiliza√ß√£o pronta para nosso *Markdown*:

```sh
yarn add @tailwindcss/typography
```

Com o *plugin* instalado, adicione o requerimento do *plugin* no arquivo `tailwind.config.js`

```js filename=tailwind.config.js lines=6
module.exports = {
  theme: {
    // ...
  },
  plugins: [
    require('@tailwindcss/typography'),
    // ...
  ],
}
```

Agora precisamos fazer a configura√ß√£o necess√°ria para que o Tailwind fa√ßa o *tree-shake* de estilos n√£o utilizados nas *builds* de produ√ß√£o:

```diff
module.exports = {
-  purge: [],
+  purge: ['./pages/**/*.{js,ts,jsx,tsx}', './components/**/*.{js,ts,jsx,tsx}'],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [
    require('@tailwindcss/typography'),
  ],
}
```
*O Tailwind vem com muitas classes CSS de apoio para constru√ß√£o do layout. Em produ√ß√£o, queremos garantir que s√≥ classes que utilizamos estejam disponiv√©is.*


Para utilizarmos todas essas classes, importaremos no arquivo `pages/_app.js` o arquivo CSS do Tailwind.

```diff filename=pages/_app.js
- import '../styles/globals.css'
+ import 'tailwindcss/tailwind.css'

function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />
}

export default MyApp
```

Pronto, estamos prontos para come√ßar a codar!

## Dando uma carinha legal para nossa p√°gina inicial

Vamos come√ßar a usar o Tailwind para dar uma cara pra p√°gina inicial. A id√©ia √© ter uma p√°gina com o t√≠tulo do nosso site e com cards para exibirmos nossas postagens.

Iremos componentizar esse `Card` e alterar nossa p√°gina inicial para usar Tailwind:

```jsx filename=components/Card.js
import Link from 'next/link'

function Card({ title, description, href }) {
  return (
    <Link href={href} passHref>
      <a className="m-4 p-5 text-left no-underline border border-gray-500 rounded-xl transition-colors hover:text-blue-700 hover:border-blue-700">
        <h2 className="text-2xl">{title} &rarr;</h2>
        <p>{description}</p>
      </a>
    </Link>
  )
}

export default Card
```

As classes para utiliza√ß√£o do Tailwind √© bem intuitiva e bem parecida com o pr√≥prio CSS. Por exemplo:
- `m-4`: *Margin* com o espa√ßamento 4 do padr√£o. Aplica tanto na esquerda-direita quanto cima-baixo;
- `hover:text-blue-700`: altera a cor do texto ao passar o mouse por cima do elemento.

√â bem intuitivo mexer. Aconselho a instalar a extens√£o de *auto-complete* para o VSCode que √© simplesmente fantastica!

```jsx filename=pages/index.js
import Head from 'next/head'

import Card from '../components/Card'

export default function Home() {
  return (
    <div className='min-h-screen px-2 flex flex-col justify-center items-center h-screen'>
      <Head>
        <title>My Next Blog</title>
      </Head>

      <main className="py-20 flex-1 flex flex-col justify-center items-center">
        <h1 className="text-4xl md:text-6xl">
          Meu blog üòú
        </h1>

        <div className="grid grid-cols-1 md:grid-cols-2 mt-6">
          <Card
            href="#"
            title="Invertendo linked lists"
            description="Descubra o segredo milenar para inverter uma linked list."
          />
        </div>
      </main>

      <footer className='p-6'>
          Powered by Next + MDX
      </footer>
    </div>
  )
}
```

Continuando, vamos para a parte interessante e onde tudo vai acontecer. Iremos criar uma rota que receber√° um par√¢metro que iremos chamar de `slug`. Lembrando que no Next, ao criar um arquivo com `[` e fechando com `]` ele considera essa rota din√¢mica! Ent√£o precisaremos falar para o Next quais rotas dos `posts` deveremos montar em tempo de build. Faremos isso mais para frente!

```jsx filename=pages/posts/[slug].js
function PostPage({ slug }) {
  return <h1>{slug}</h1>
}

export const getStaticProps = async ({ params }) => {
  return {
    props: {
      slug: params.slug
    },
  }
}

export const getStaticPaths = async () => {
  return {
    paths: [{ params: { slug: 'teste' } }],
    fallback: false,
  }
}

export default PostPage
```

A p√°gina em si n√£o est√° fazendo nada demais ainda. Estamos pegando o `slug` dos `params` e repassando para o componente `build time`. A √∫nica rota at√© ent√£o permitida √© a rota `teste` tamb√©m. Em breve tornaremos din√¢mico baseado em nossos `posts`.

- `getStaticProps` ser√° respons√°vel de carregar o arquivo e mandar todas as informa√ß√µes necess√°rias para o componente quando a aplica√ß√£o for *buildada*.
- `getStaticPaths` √© respons√°vel por dinamicamente informar quais rotas dever√£o ser montadas no *build*.

A utliza√ß√£o desses m√©todos em conjunto, na forma em que foi usada, √© o que chamamos de *Static Site Generation*.

> Para ler mais sobre *Static Site Generation*, acesse a documenta√ß√£o do Next.js [aqui](https://nextjs.org/docs/basic-features/pages#static-generation-recommended).

Vamos popular esses met√≥dos com as fun√ß√µes do `next-mdx-remote`. Antes disso, na ra√≠z do projeto vamos criar uma pasta chamada `posts` e um arquivo chamado `primeiro-post.mdx` (tente seguir esse padr√£o *slugifado* para manter as URLs da sua aplica√ß√£o consistentes).

```mdx filename=posts/primeiro-post.mdx
---
title: Meu primeiro post!
description: Essa descri√ß√£o do frontmatter.
---

Esse post √© um exemplo com [link](https://nextjs.org).

O t√≠tulo e a descri√ß√£o s√£o processados usando o `gray-matter`.
```

Todo metadado da postagem ficar√° entre os `---` logo no √≠nicio do arquivo. Esse √≠nicio sera formatado pela depend√™ncia `gray-matter` automaticamente.

Para gerar as p√°ginas precisamos carregar o arquivo referente ao `slug` da nossa pasta de posts. Vamos criar um arquivo que servir√° de auxilio para carregar esses posts:

```js filename=utils/mdxUtils.js
import fs from 'fs'
import path from 'path'

// POSTS_PATH √© util quando voc√™ quer pegar o caminho espec√≠fico do arquivo
export const POSTS_PATH = path.join(process.cwd(), 'posts')

// postFilePaths √© a lista de todos os arquivos mdx dentro do diret√≥rio POSTS_PATHS
export const postFilePaths = fs
  .readdirSync(POSTS_PATH)
  // Inlcui apenas arquivos md(x)
  .filter((path) => /\.mdx?$/.test(path))
```

Utilizando esses m√©todos iremos carregar toda informa√ß√£o necess√°ria para o componente. Altere o `getStaticProps` e `getStaticPaths` do arquivo da p√°gina de posts:


```jsx filename=pages/posts/[slug].js lines=8,9,10
import fs from 'fs'
import path from 'path'
import matter from 'gray-matter'
import { serialize } from 'next-mdx-remote/serialize'

import { postFilePaths, POSTS_PATH } from '../../utils/mdxUtils'

function PostPage({ source, frontMatter }) {
  return <h1>Post</h1>
}

export const getStaticProps = async ({ params }) => {
  const postFilePath = path.join(POSTS_PATH, `${params.slug}.mdx`)
  const source = fs.readFileSync(postFilePath)

  const { content, data } = matter(source)

  const mdxSource = await serialize(content, {
    mdxOptions: {
      remarkPlugins: [],
      rehypePlugins: [],
    },
    scope: data,
  })

  return {
    props: {
      source: mdxSource,
      frontMatter: data,
    },
  }
}

export const getStaticPaths = async () => {
  const paths = postFilePaths
    // Remove a extens√£o dos arquivos para montar as rotas
    .map((path) => path.replace(/\.mdx?$/, ''))
    // Mapeia para os parametros estaticos requeridos pelo Next.js
    .map((slug) => ({ params: { slug } }))

  return {
    paths,
    fallback: false,
  }
}

export default PostPage
```

Dei uma leve altareda no componente para ajeitar para os props que o `getStaticProps` ir√° passar:

- **source**: √© o conte√∫do do post, ele √© serializado pelo `next-mdx-remote` e ser√° utlizado no componente do mesmo.
- **frontMatter**: como citado mais em cima, √© todo metadado que voc√™ pode incluir no post, seja t√≠tulo, descri√ß√£o, imagens, ligugagem, etc...

Para finalizar a composi√ß√£o do componente da nossa p√°gina, basta apenas apresentar o cont√©udo utilizando o componente `MDXRemote` exportado pelo `next-mdx-remote`. Todo o restante iremos pegar do `frontMatter`:

```jsx filename=pages/posts/[slug].js lines=2
...
import { MDXRemote } from 'next-mdx-remote'
...
function PostPage({ source, frontMatter }) {
  return (
    <div className="prose p-12">
      <h1>{frontMatter.title}</h1>
      {frontMatter.description && (
        <p className="description">{frontMatter.description}</p>
      )}
      <main>
        <MDXRemote {...source} />
      </main>
    </div>
  )
}
...
```

Aplicando a classe `prose` do Tailwind, todo nosso markdown j√° ter√° um estilo pronto para tratar nosso *markdown*.

Pronto, ao acessar o link do nosso post basta navegar at√© [http://localhost:3000/posts/primeiro-post](http://localhost:3000/posts/primeiro-post).

![Primeiro post!](https://res.cloudinary.com/ilher-dev/image/upload/v1634395542/Screenshot_from_2021-10-16_11-44-17_dbqjpt.webp)

Para finalizar, iremos at√© nosso arquivo da p√°gina inicial, e carregaremos os posts de uma forma semelhante a p√°gina de post. No entanto, para p√°gina inicial, n√£o √© necess√°rio serializar o cont√©udo, apenas pegar os metadados com o `gray-matter`.

```jsx filename=pages/index.js lines=3,4,5,6,23,24,25,26,27,28,29,30,41,42,43,44,45,46,47,48,49,50,51,52,53,54
import Head from 'next/head'

import path from 'path'
import fs from 'fs'
import matter from 'gray-matter'
import { postFilePaths, POSTS_PATH } from '../utils/mdxUtils'

import Card from '../components/Card'

export default function Home({ posts }) {
  return (
    <div className='min-h-screen px-2 flex flex-col justify-center items-center h-screen'>
      <Head>
        <title>My Next Blog</title>
      </Head>

      <main className="py-20 flex-1 flex flex-col justify-center items-center">
        <h1 className="text-4xl md:text-6xl">
          Meu blog üòú
        </h1>

        <div className="grid grid-cols-1 md:grid-cols-2 mt-6">
          {posts.map((post) => (
            <Card
              key={post.filePath}
              href={`/posts/${post.filePath.replace(/\.mdx?$/, '')}`}
              title={post.data.title}
              description={post.data.description}
            />
          ))}
        </div>
      </main>

      <footer className='p-6'>
          Powered by Next + MDX
      </footer>
    </div>
  )
}

export const getStaticProps = () => {
  const posts = postFilePaths.map((filePath) => {
    const source = fs.readFileSync(path.join(POSTS_PATH, filePath))
    const { content, data } = matter(source)

    return {
      content,
      data,
      filePath,
    }
  })

  return { props: { posts } }
}
```

![P√°gina inicial!](https://res.cloudinary.com/ilher-dev/image/upload/v1634396534/Screenshot_from_2021-10-16_12-02-02_sbmkr9.webp)

Como citei no inicio da postagem, √© poss√≠vel importar componentes React para nosso arquivo MDX. Para isso, devemos fornecer um objeto de componentes para o `MDXRemote`. Irei criar um componente de contador simples como teste:

```jsx filename=components/Test.js
import { useState } from 'react'

function Test() {
  const [counter, setCounter] = useState(0)

  return (
    <div>
      {counter}
      <button
        type="button"
        onClick={() => setCounter(c => c + 1)}
        className="m-2 bg-gray-300 p-4"
      >
          +
        </button>
      <button
        type="button"
        onClick={() => setCounter(c => c - 1)}
        className="m-2 bg-gray-300 p-4"
      >
        -
      </button>
    </div>
  )
}

export default Test
```

Voltando no arquivo `pages/posts/[slug].js` vamos importar, criar um objeto contendo esse componente e prover para o componente `MDXRemote`

```jsx filename=pages/posts/[slug].jsx lines=2,5,15
...
import Test from '../../components/Test'
...

const components = { Test }

function PostPage({ source, frontMatter }) {
  return (
    <div className="prose p-12">
      <h1>{frontMatter.title}</h1>
      {frontMatter.description && (
        <p className="description">{frontMatter.description}</p>
      )}
      <main>
        <MDXRemote {...source} components={components} />
      </main>
    </div>
  )
}
...
```

O componente `Test` estar√° dispon√≠vel dentro do contexto do MDX. Podemos usa-lo normalmente em nosso arquivo `.mdx` agora:

```mdx filename=posts/primeiro-post.mdx
---
title: Meu primeiro post!
description: Essa descri√ß√£o do frontmatter.
---

Esse post √© um exemplo com [link](https://nextjs.org).

O t√≠tulo e a descri√ß√£o s√£o processados usando o `gray-matter`.

<Test />
```

E agora temos um componente de contador em nosso MDX!

![Aplica√ß√£o com contador](https://res.cloudinary.com/ilher-dev/image/upload/v1634472303/app-blog_icvjf2.gif)

## Finalizando o projeto

Agora com o projeto finalizado, voc√™ pode fazer o *deploy* na Vercel, do mesmo jeito que esse meu blog √©! Caso queiram conferir o c√≥digo fonte do projeto final basta acessar o reposit√≥rio:

<GithubCard title="nextjs-blog" description="Next.js + MDX blog" language="Javascript" href="#" />
